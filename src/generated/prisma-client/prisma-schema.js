module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateComment {
  count: Int!
}

type AggregateCommentLike {
  count: Int!
}

type AggregateExternalAccount {
  count: Int!
}

type AggregateProject {
  count: Int!
}

type AggregateProjectLike {
  count: Int!
}

type AggregateUserAccount {
  count: Int!
}

type AggregateUserProfile {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Comment {
  id: ID!
  profile: UserProfile!
  project: Project!
  text: String!
  likes(where: CommentLikeWhereInput, orderBy: CommentLikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CommentLike!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CommentConnection {
  pageInfo: PageInfo!
  edges: [CommentEdge]!
  aggregate: AggregateComment!
}

input CommentCreateInput {
  id: ID
  profile: UserProfileCreateOneWithoutCommentsInput!
  project: ProjectCreateOneWithoutCommentsInput!
  text: String!
  likes: CommentLikeCreateManyWithoutCommentInput
}

input CommentCreateManyWithoutProfileInput {
  create: [CommentCreateWithoutProfileInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateManyWithoutProjectInput {
  create: [CommentCreateWithoutProjectInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateOneWithoutLikesInput {
  create: CommentCreateWithoutLikesInput
  connect: CommentWhereUniqueInput
}

input CommentCreateWithoutLikesInput {
  id: ID
  profile: UserProfileCreateOneWithoutCommentsInput!
  project: ProjectCreateOneWithoutCommentsInput!
  text: String!
}

input CommentCreateWithoutProfileInput {
  id: ID
  project: ProjectCreateOneWithoutCommentsInput!
  text: String!
  likes: CommentLikeCreateManyWithoutCommentInput
}

input CommentCreateWithoutProjectInput {
  id: ID
  profile: UserProfileCreateOneWithoutCommentsInput!
  text: String!
  likes: CommentLikeCreateManyWithoutCommentInput
}

type CommentEdge {
  node: Comment!
  cursor: String!
}

type CommentLike {
  id: ID!
  profile: UserProfile!
  comment: Comment!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CommentLikeConnection {
  pageInfo: PageInfo!
  edges: [CommentLikeEdge]!
  aggregate: AggregateCommentLike!
}

input CommentLikeCreateInput {
  id: ID
  profile: UserProfileCreateOneWithoutCommentLikesInput!
  comment: CommentCreateOneWithoutLikesInput!
}

input CommentLikeCreateManyWithoutCommentInput {
  create: [CommentLikeCreateWithoutCommentInput!]
  connect: [CommentLikeWhereUniqueInput!]
}

input CommentLikeCreateManyWithoutProfileInput {
  create: [CommentLikeCreateWithoutProfileInput!]
  connect: [CommentLikeWhereUniqueInput!]
}

input CommentLikeCreateWithoutCommentInput {
  id: ID
  profile: UserProfileCreateOneWithoutCommentLikesInput!
}

input CommentLikeCreateWithoutProfileInput {
  id: ID
  comment: CommentCreateOneWithoutLikesInput!
}

type CommentLikeEdge {
  node: CommentLike!
  cursor: String!
}

enum CommentLikeOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CommentLikePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input CommentLikeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CommentLikeScalarWhereInput!]
  OR: [CommentLikeScalarWhereInput!]
  NOT: [CommentLikeScalarWhereInput!]
}

type CommentLikeSubscriptionPayload {
  mutation: MutationType!
  node: CommentLike
  updatedFields: [String!]
  previousValues: CommentLikePreviousValues
}

input CommentLikeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentLikeWhereInput
  AND: [CommentLikeSubscriptionWhereInput!]
  OR: [CommentLikeSubscriptionWhereInput!]
  NOT: [CommentLikeSubscriptionWhereInput!]
}

input CommentLikeUpdateInput {
  profile: UserProfileUpdateOneRequiredWithoutCommentLikesInput
  comment: CommentUpdateOneRequiredWithoutLikesInput
}

input CommentLikeUpdateManyWithoutCommentInput {
  create: [CommentLikeCreateWithoutCommentInput!]
  delete: [CommentLikeWhereUniqueInput!]
  connect: [CommentLikeWhereUniqueInput!]
  set: [CommentLikeWhereUniqueInput!]
  disconnect: [CommentLikeWhereUniqueInput!]
  update: [CommentLikeUpdateWithWhereUniqueWithoutCommentInput!]
  upsert: [CommentLikeUpsertWithWhereUniqueWithoutCommentInput!]
  deleteMany: [CommentLikeScalarWhereInput!]
}

input CommentLikeUpdateManyWithoutProfileInput {
  create: [CommentLikeCreateWithoutProfileInput!]
  delete: [CommentLikeWhereUniqueInput!]
  connect: [CommentLikeWhereUniqueInput!]
  set: [CommentLikeWhereUniqueInput!]
  disconnect: [CommentLikeWhereUniqueInput!]
  update: [CommentLikeUpdateWithWhereUniqueWithoutProfileInput!]
  upsert: [CommentLikeUpsertWithWhereUniqueWithoutProfileInput!]
  deleteMany: [CommentLikeScalarWhereInput!]
}

input CommentLikeUpdateWithoutCommentDataInput {
  profile: UserProfileUpdateOneRequiredWithoutCommentLikesInput
}

input CommentLikeUpdateWithoutProfileDataInput {
  comment: CommentUpdateOneRequiredWithoutLikesInput
}

input CommentLikeUpdateWithWhereUniqueWithoutCommentInput {
  where: CommentLikeWhereUniqueInput!
  data: CommentLikeUpdateWithoutCommentDataInput!
}

input CommentLikeUpdateWithWhereUniqueWithoutProfileInput {
  where: CommentLikeWhereUniqueInput!
  data: CommentLikeUpdateWithoutProfileDataInput!
}

input CommentLikeUpsertWithWhereUniqueWithoutCommentInput {
  where: CommentLikeWhereUniqueInput!
  update: CommentLikeUpdateWithoutCommentDataInput!
  create: CommentLikeCreateWithoutCommentInput!
}

input CommentLikeUpsertWithWhereUniqueWithoutProfileInput {
  where: CommentLikeWhereUniqueInput!
  update: CommentLikeUpdateWithoutProfileDataInput!
  create: CommentLikeCreateWithoutProfileInput!
}

input CommentLikeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  profile: UserProfileWhereInput
  comment: CommentWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CommentLikeWhereInput!]
  OR: [CommentLikeWhereInput!]
  NOT: [CommentLikeWhereInput!]
}

input CommentLikeWhereUniqueInput {
  id: ID
}

enum CommentOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CommentPreviousValues {
  id: ID!
  text: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input CommentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  updatedFields: [String!]
  previousValues: CommentPreviousValues
}

input CommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentWhereInput
  AND: [CommentSubscriptionWhereInput!]
  OR: [CommentSubscriptionWhereInput!]
  NOT: [CommentSubscriptionWhereInput!]
}

input CommentUpdateInput {
  profile: UserProfileUpdateOneRequiredWithoutCommentsInput
  project: ProjectUpdateOneRequiredWithoutCommentsInput
  text: String
  likes: CommentLikeUpdateManyWithoutCommentInput
}

input CommentUpdateManyDataInput {
  text: String
}

input CommentUpdateManyMutationInput {
  text: String
}

input CommentUpdateManyWithoutProfileInput {
  create: [CommentCreateWithoutProfileInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutProfileInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutProfileInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithoutProjectInput {
  create: [CommentCreateWithoutProjectInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutProjectInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutProjectInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyDataInput!
}

input CommentUpdateOneRequiredWithoutLikesInput {
  create: CommentCreateWithoutLikesInput
  update: CommentUpdateWithoutLikesDataInput
  upsert: CommentUpsertWithoutLikesInput
  connect: CommentWhereUniqueInput
}

input CommentUpdateWithoutLikesDataInput {
  profile: UserProfileUpdateOneRequiredWithoutCommentsInput
  project: ProjectUpdateOneRequiredWithoutCommentsInput
  text: String
}

input CommentUpdateWithoutProfileDataInput {
  project: ProjectUpdateOneRequiredWithoutCommentsInput
  text: String
  likes: CommentLikeUpdateManyWithoutCommentInput
}

input CommentUpdateWithoutProjectDataInput {
  profile: UserProfileUpdateOneRequiredWithoutCommentsInput
  text: String
  likes: CommentLikeUpdateManyWithoutCommentInput
}

input CommentUpdateWithWhereUniqueWithoutProfileInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutProfileDataInput!
}

input CommentUpdateWithWhereUniqueWithoutProjectInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutProjectDataInput!
}

input CommentUpsertWithoutLikesInput {
  update: CommentUpdateWithoutLikesDataInput!
  create: CommentCreateWithoutLikesInput!
}

input CommentUpsertWithWhereUniqueWithoutProfileInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutProfileDataInput!
  create: CommentCreateWithoutProfileInput!
}

input CommentUpsertWithWhereUniqueWithoutProjectInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutProjectDataInput!
  create: CommentCreateWithoutProjectInput!
}

input CommentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  profile: UserProfileWhereInput
  project: ProjectWhereInput
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  likes_every: CommentLikeWhereInput
  likes_some: CommentLikeWhereInput
  likes_none: CommentLikeWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
}

input CommentWhereUniqueInput {
  id: ID
}

scalar DateTime

type ExternalAccount {
  id: ID!
  accountId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ExternalAccountConnection {
  pageInfo: PageInfo!
  edges: [ExternalAccountEdge]!
  aggregate: AggregateExternalAccount!
}

input ExternalAccountCreateInput {
  id: ID
  accountId: ID!
}

type ExternalAccountEdge {
  node: ExternalAccount!
  cursor: String!
}

enum ExternalAccountOrderByInput {
  id_ASC
  id_DESC
  accountId_ASC
  accountId_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ExternalAccountPreviousValues {
  id: ID!
  accountId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ExternalAccountSubscriptionPayload {
  mutation: MutationType!
  node: ExternalAccount
  updatedFields: [String!]
  previousValues: ExternalAccountPreviousValues
}

input ExternalAccountSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExternalAccountWhereInput
  AND: [ExternalAccountSubscriptionWhereInput!]
  OR: [ExternalAccountSubscriptionWhereInput!]
  NOT: [ExternalAccountSubscriptionWhereInput!]
}

input ExternalAccountUpdateInput {
  accountId: ID
}

input ExternalAccountUpdateManyMutationInput {
  accountId: ID
}

input ExternalAccountWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  accountId: ID
  accountId_not: ID
  accountId_in: [ID!]
  accountId_not_in: [ID!]
  accountId_lt: ID
  accountId_lte: ID
  accountId_gt: ID
  accountId_gte: ID
  accountId_contains: ID
  accountId_not_contains: ID
  accountId_starts_with: ID
  accountId_not_starts_with: ID
  accountId_ends_with: ID
  accountId_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ExternalAccountWhereInput!]
  OR: [ExternalAccountWhereInput!]
  NOT: [ExternalAccountWhereInput!]
}

input ExternalAccountWhereUniqueInput {
  id: ID
  accountId: ID
}

scalar Long

type Mutation {
  createComment(data: CommentCreateInput!): Comment!
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateManyComments(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload!
  upsertComment(where: CommentWhereUniqueInput!, create: CommentCreateInput!, update: CommentUpdateInput!): Comment!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  createCommentLike(data: CommentLikeCreateInput!): CommentLike!
  updateCommentLike(data: CommentLikeUpdateInput!, where: CommentLikeWhereUniqueInput!): CommentLike
  upsertCommentLike(where: CommentLikeWhereUniqueInput!, create: CommentLikeCreateInput!, update: CommentLikeUpdateInput!): CommentLike!
  deleteCommentLike(where: CommentLikeWhereUniqueInput!): CommentLike
  deleteManyCommentLikes(where: CommentLikeWhereInput): BatchPayload!
  createExternalAccount(data: ExternalAccountCreateInput!): ExternalAccount!
  updateExternalAccount(data: ExternalAccountUpdateInput!, where: ExternalAccountWhereUniqueInput!): ExternalAccount
  updateManyExternalAccounts(data: ExternalAccountUpdateManyMutationInput!, where: ExternalAccountWhereInput): BatchPayload!
  upsertExternalAccount(where: ExternalAccountWhereUniqueInput!, create: ExternalAccountCreateInput!, update: ExternalAccountUpdateInput!): ExternalAccount!
  deleteExternalAccount(where: ExternalAccountWhereUniqueInput!): ExternalAccount
  deleteManyExternalAccounts(where: ExternalAccountWhereInput): BatchPayload!
  createProject(data: ProjectCreateInput!): Project!
  updateProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateManyProjects(data: ProjectUpdateManyMutationInput!, where: ProjectWhereInput): BatchPayload!
  upsertProject(where: ProjectWhereUniqueInput!, create: ProjectCreateInput!, update: ProjectUpdateInput!): Project!
  deleteProject(where: ProjectWhereUniqueInput!): Project
  deleteManyProjects(where: ProjectWhereInput): BatchPayload!
  createProjectLike(data: ProjectLikeCreateInput!): ProjectLike!
  updateProjectLike(data: ProjectLikeUpdateInput!, where: ProjectLikeWhereUniqueInput!): ProjectLike
  upsertProjectLike(where: ProjectLikeWhereUniqueInput!, create: ProjectLikeCreateInput!, update: ProjectLikeUpdateInput!): ProjectLike!
  deleteProjectLike(where: ProjectLikeWhereUniqueInput!): ProjectLike
  deleteManyProjectLikes(where: ProjectLikeWhereInput): BatchPayload!
  createUserAccount(data: UserAccountCreateInput!): UserAccount!
  updateUserAccount(data: UserAccountUpdateInput!, where: UserAccountWhereUniqueInput!): UserAccount
  updateManyUserAccounts(data: UserAccountUpdateManyMutationInput!, where: UserAccountWhereInput): BatchPayload!
  upsertUserAccount(where: UserAccountWhereUniqueInput!, create: UserAccountCreateInput!, update: UserAccountUpdateInput!): UserAccount!
  deleteUserAccount(where: UserAccountWhereUniqueInput!): UserAccount
  deleteManyUserAccounts(where: UserAccountWhereInput): BatchPayload!
  createUserProfile(data: UserProfileCreateInput!): UserProfile!
  updateUserProfile(data: UserProfileUpdateInput!, where: UserProfileWhereUniqueInput!): UserProfile
  updateManyUserProfiles(data: UserProfileUpdateManyMutationInput!, where: UserProfileWhereInput): BatchPayload!
  upsertUserProfile(where: UserProfileWhereUniqueInput!, create: UserProfileCreateInput!, update: UserProfileUpdateInput!): UserProfile!
  deleteUserProfile(where: UserProfileWhereUniqueInput!): UserProfile
  deleteManyUserProfiles(where: UserProfileWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Project {
  id: ID!
  profile: UserProfile!
  name: String!
  description: String!
  address: String!
  state: String!
  zip: Int!
  city: String!
  goalAmount: Float!
  amountFunded: Float!
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  likes(where: ProjectLikeWhereInput, orderBy: ProjectLikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectLike!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProjectConnection {
  pageInfo: PageInfo!
  edges: [ProjectEdge]!
  aggregate: AggregateProject!
}

input ProjectCreateInput {
  id: ID
  profile: UserProfileCreateOneWithoutProjectsInput!
  name: String!
  description: String!
  address: String!
  state: String!
  zip: Int!
  city: String!
  goalAmount: Float!
  amountFunded: Float
  comments: CommentCreateManyWithoutProjectInput
  likes: ProjectLikeCreateManyWithoutProjectInput
}

input ProjectCreateManyWithoutProfileInput {
  create: [ProjectCreateWithoutProfileInput!]
  connect: [ProjectWhereUniqueInput!]
}

input ProjectCreateOneWithoutCommentsInput {
  create: ProjectCreateWithoutCommentsInput
  connect: ProjectWhereUniqueInput
}

input ProjectCreateOneWithoutLikesInput {
  create: ProjectCreateWithoutLikesInput
  connect: ProjectWhereUniqueInput
}

input ProjectCreateWithoutCommentsInput {
  id: ID
  profile: UserProfileCreateOneWithoutProjectsInput!
  name: String!
  description: String!
  address: String!
  state: String!
  zip: Int!
  city: String!
  goalAmount: Float!
  amountFunded: Float
  likes: ProjectLikeCreateManyWithoutProjectInput
}

input ProjectCreateWithoutLikesInput {
  id: ID
  profile: UserProfileCreateOneWithoutProjectsInput!
  name: String!
  description: String!
  address: String!
  state: String!
  zip: Int!
  city: String!
  goalAmount: Float!
  amountFunded: Float
  comments: CommentCreateManyWithoutProjectInput
}

input ProjectCreateWithoutProfileInput {
  id: ID
  name: String!
  description: String!
  address: String!
  state: String!
  zip: Int!
  city: String!
  goalAmount: Float!
  amountFunded: Float
  comments: CommentCreateManyWithoutProjectInput
  likes: ProjectLikeCreateManyWithoutProjectInput
}

type ProjectEdge {
  node: Project!
  cursor: String!
}

type ProjectLike {
  id: ID!
  profile: UserProfile!
  project: Project!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProjectLikeConnection {
  pageInfo: PageInfo!
  edges: [ProjectLikeEdge]!
  aggregate: AggregateProjectLike!
}

input ProjectLikeCreateInput {
  id: ID
  profile: UserProfileCreateOneWithoutProjectLikesInput!
  project: ProjectCreateOneWithoutLikesInput!
}

input ProjectLikeCreateManyWithoutProfileInput {
  create: [ProjectLikeCreateWithoutProfileInput!]
  connect: [ProjectLikeWhereUniqueInput!]
}

input ProjectLikeCreateManyWithoutProjectInput {
  create: [ProjectLikeCreateWithoutProjectInput!]
  connect: [ProjectLikeWhereUniqueInput!]
}

input ProjectLikeCreateWithoutProfileInput {
  id: ID
  project: ProjectCreateOneWithoutLikesInput!
}

input ProjectLikeCreateWithoutProjectInput {
  id: ID
  profile: UserProfileCreateOneWithoutProjectLikesInput!
}

type ProjectLikeEdge {
  node: ProjectLike!
  cursor: String!
}

enum ProjectLikeOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProjectLikePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ProjectLikeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProjectLikeScalarWhereInput!]
  OR: [ProjectLikeScalarWhereInput!]
  NOT: [ProjectLikeScalarWhereInput!]
}

type ProjectLikeSubscriptionPayload {
  mutation: MutationType!
  node: ProjectLike
  updatedFields: [String!]
  previousValues: ProjectLikePreviousValues
}

input ProjectLikeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectLikeWhereInput
  AND: [ProjectLikeSubscriptionWhereInput!]
  OR: [ProjectLikeSubscriptionWhereInput!]
  NOT: [ProjectLikeSubscriptionWhereInput!]
}

input ProjectLikeUpdateInput {
  profile: UserProfileUpdateOneRequiredWithoutProjectLikesInput
  project: ProjectUpdateOneRequiredWithoutLikesInput
}

input ProjectLikeUpdateManyWithoutProfileInput {
  create: [ProjectLikeCreateWithoutProfileInput!]
  delete: [ProjectLikeWhereUniqueInput!]
  connect: [ProjectLikeWhereUniqueInput!]
  set: [ProjectLikeWhereUniqueInput!]
  disconnect: [ProjectLikeWhereUniqueInput!]
  update: [ProjectLikeUpdateWithWhereUniqueWithoutProfileInput!]
  upsert: [ProjectLikeUpsertWithWhereUniqueWithoutProfileInput!]
  deleteMany: [ProjectLikeScalarWhereInput!]
}

input ProjectLikeUpdateManyWithoutProjectInput {
  create: [ProjectLikeCreateWithoutProjectInput!]
  delete: [ProjectLikeWhereUniqueInput!]
  connect: [ProjectLikeWhereUniqueInput!]
  set: [ProjectLikeWhereUniqueInput!]
  disconnect: [ProjectLikeWhereUniqueInput!]
  update: [ProjectLikeUpdateWithWhereUniqueWithoutProjectInput!]
  upsert: [ProjectLikeUpsertWithWhereUniqueWithoutProjectInput!]
  deleteMany: [ProjectLikeScalarWhereInput!]
}

input ProjectLikeUpdateWithoutProfileDataInput {
  project: ProjectUpdateOneRequiredWithoutLikesInput
}

input ProjectLikeUpdateWithoutProjectDataInput {
  profile: UserProfileUpdateOneRequiredWithoutProjectLikesInput
}

input ProjectLikeUpdateWithWhereUniqueWithoutProfileInput {
  where: ProjectLikeWhereUniqueInput!
  data: ProjectLikeUpdateWithoutProfileDataInput!
}

input ProjectLikeUpdateWithWhereUniqueWithoutProjectInput {
  where: ProjectLikeWhereUniqueInput!
  data: ProjectLikeUpdateWithoutProjectDataInput!
}

input ProjectLikeUpsertWithWhereUniqueWithoutProfileInput {
  where: ProjectLikeWhereUniqueInput!
  update: ProjectLikeUpdateWithoutProfileDataInput!
  create: ProjectLikeCreateWithoutProfileInput!
}

input ProjectLikeUpsertWithWhereUniqueWithoutProjectInput {
  where: ProjectLikeWhereUniqueInput!
  update: ProjectLikeUpdateWithoutProjectDataInput!
  create: ProjectLikeCreateWithoutProjectInput!
}

input ProjectLikeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  profile: UserProfileWhereInput
  project: ProjectWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProjectLikeWhereInput!]
  OR: [ProjectLikeWhereInput!]
  NOT: [ProjectLikeWhereInput!]
}

input ProjectLikeWhereUniqueInput {
  id: ID
}

enum ProjectOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  address_ASC
  address_DESC
  state_ASC
  state_DESC
  zip_ASC
  zip_DESC
  city_ASC
  city_DESC
  goalAmount_ASC
  goalAmount_DESC
  amountFunded_ASC
  amountFunded_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProjectPreviousValues {
  id: ID!
  name: String!
  description: String!
  address: String!
  state: String!
  zip: Int!
  city: String!
  goalAmount: Float!
  amountFunded: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ProjectScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  zip: Int
  zip_not: Int
  zip_in: [Int!]
  zip_not_in: [Int!]
  zip_lt: Int
  zip_lte: Int
  zip_gt: Int
  zip_gte: Int
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  goalAmount: Float
  goalAmount_not: Float
  goalAmount_in: [Float!]
  goalAmount_not_in: [Float!]
  goalAmount_lt: Float
  goalAmount_lte: Float
  goalAmount_gt: Float
  goalAmount_gte: Float
  amountFunded: Float
  amountFunded_not: Float
  amountFunded_in: [Float!]
  amountFunded_not_in: [Float!]
  amountFunded_lt: Float
  amountFunded_lte: Float
  amountFunded_gt: Float
  amountFunded_gte: Float
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProjectScalarWhereInput!]
  OR: [ProjectScalarWhereInput!]
  NOT: [ProjectScalarWhereInput!]
}

type ProjectSubscriptionPayload {
  mutation: MutationType!
  node: Project
  updatedFields: [String!]
  previousValues: ProjectPreviousValues
}

input ProjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectWhereInput
  AND: [ProjectSubscriptionWhereInput!]
  OR: [ProjectSubscriptionWhereInput!]
  NOT: [ProjectSubscriptionWhereInput!]
}

input ProjectUpdateInput {
  profile: UserProfileUpdateOneRequiredWithoutProjectsInput
  name: String
  description: String
  address: String
  state: String
  zip: Int
  city: String
  goalAmount: Float
  amountFunded: Float
  comments: CommentUpdateManyWithoutProjectInput
  likes: ProjectLikeUpdateManyWithoutProjectInput
}

input ProjectUpdateManyDataInput {
  name: String
  description: String
  address: String
  state: String
  zip: Int
  city: String
  goalAmount: Float
  amountFunded: Float
}

input ProjectUpdateManyMutationInput {
  name: String
  description: String
  address: String
  state: String
  zip: Int
  city: String
  goalAmount: Float
  amountFunded: Float
}

input ProjectUpdateManyWithoutProfileInput {
  create: [ProjectCreateWithoutProfileInput!]
  delete: [ProjectWhereUniqueInput!]
  connect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  disconnect: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutProfileInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutProfileInput!]
  deleteMany: [ProjectScalarWhereInput!]
  updateMany: [ProjectUpdateManyWithWhereNestedInput!]
}

input ProjectUpdateManyWithWhereNestedInput {
  where: ProjectScalarWhereInput!
  data: ProjectUpdateManyDataInput!
}

input ProjectUpdateOneRequiredWithoutCommentsInput {
  create: ProjectCreateWithoutCommentsInput
  update: ProjectUpdateWithoutCommentsDataInput
  upsert: ProjectUpsertWithoutCommentsInput
  connect: ProjectWhereUniqueInput
}

input ProjectUpdateOneRequiredWithoutLikesInput {
  create: ProjectCreateWithoutLikesInput
  update: ProjectUpdateWithoutLikesDataInput
  upsert: ProjectUpsertWithoutLikesInput
  connect: ProjectWhereUniqueInput
}

input ProjectUpdateWithoutCommentsDataInput {
  profile: UserProfileUpdateOneRequiredWithoutProjectsInput
  name: String
  description: String
  address: String
  state: String
  zip: Int
  city: String
  goalAmount: Float
  amountFunded: Float
  likes: ProjectLikeUpdateManyWithoutProjectInput
}

input ProjectUpdateWithoutLikesDataInput {
  profile: UserProfileUpdateOneRequiredWithoutProjectsInput
  name: String
  description: String
  address: String
  state: String
  zip: Int
  city: String
  goalAmount: Float
  amountFunded: Float
  comments: CommentUpdateManyWithoutProjectInput
}

input ProjectUpdateWithoutProfileDataInput {
  name: String
  description: String
  address: String
  state: String
  zip: Int
  city: String
  goalAmount: Float
  amountFunded: Float
  comments: CommentUpdateManyWithoutProjectInput
  likes: ProjectLikeUpdateManyWithoutProjectInput
}

input ProjectUpdateWithWhereUniqueWithoutProfileInput {
  where: ProjectWhereUniqueInput!
  data: ProjectUpdateWithoutProfileDataInput!
}

input ProjectUpsertWithoutCommentsInput {
  update: ProjectUpdateWithoutCommentsDataInput!
  create: ProjectCreateWithoutCommentsInput!
}

input ProjectUpsertWithoutLikesInput {
  update: ProjectUpdateWithoutLikesDataInput!
  create: ProjectCreateWithoutLikesInput!
}

input ProjectUpsertWithWhereUniqueWithoutProfileInput {
  where: ProjectWhereUniqueInput!
  update: ProjectUpdateWithoutProfileDataInput!
  create: ProjectCreateWithoutProfileInput!
}

input ProjectWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  profile: UserProfileWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  zip: Int
  zip_not: Int
  zip_in: [Int!]
  zip_not_in: [Int!]
  zip_lt: Int
  zip_lte: Int
  zip_gt: Int
  zip_gte: Int
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  goalAmount: Float
  goalAmount_not: Float
  goalAmount_in: [Float!]
  goalAmount_not_in: [Float!]
  goalAmount_lt: Float
  goalAmount_lte: Float
  goalAmount_gt: Float
  goalAmount_gte: Float
  amountFunded: Float
  amountFunded_not: Float
  amountFunded_in: [Float!]
  amountFunded_not_in: [Float!]
  amountFunded_lt: Float
  amountFunded_lte: Float
  amountFunded_gt: Float
  amountFunded_gte: Float
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  likes_every: ProjectLikeWhereInput
  likes_some: ProjectLikeWhereInput
  likes_none: ProjectLikeWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
}

input ProjectWhereUniqueInput {
  id: ID
}

type Query {
  comment(where: CommentWhereUniqueInput!): Comment
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment]!
  commentsConnection(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentConnection!
  commentLike(where: CommentLikeWhereUniqueInput!): CommentLike
  commentLikes(where: CommentLikeWhereInput, orderBy: CommentLikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CommentLike]!
  commentLikesConnection(where: CommentLikeWhereInput, orderBy: CommentLikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentLikeConnection!
  externalAccount(where: ExternalAccountWhereUniqueInput!): ExternalAccount
  externalAccounts(where: ExternalAccountWhereInput, orderBy: ExternalAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExternalAccount]!
  externalAccountsConnection(where: ExternalAccountWhereInput, orderBy: ExternalAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExternalAccountConnection!
  project(where: ProjectWhereUniqueInput!): Project
  projects(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Project]!
  projectsConnection(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectConnection!
  projectLike(where: ProjectLikeWhereUniqueInput!): ProjectLike
  projectLikes(where: ProjectLikeWhereInput, orderBy: ProjectLikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectLike]!
  projectLikesConnection(where: ProjectLikeWhereInput, orderBy: ProjectLikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectLikeConnection!
  userAccount(where: UserAccountWhereUniqueInput!): UserAccount
  userAccounts(where: UserAccountWhereInput, orderBy: UserAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserAccount]!
  userAccountsConnection(where: UserAccountWhereInput, orderBy: UserAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserAccountConnection!
  userProfile(where: UserProfileWhereUniqueInput!): UserProfile
  userProfiles(where: UserProfileWhereInput, orderBy: UserProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserProfile]!
  userProfilesConnection(where: UserProfileWhereInput, orderBy: UserProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserProfileConnection!
  node(id: ID!): Node
}

type Subscription {
  comment(where: CommentSubscriptionWhereInput): CommentSubscriptionPayload
  commentLike(where: CommentLikeSubscriptionWhereInput): CommentLikeSubscriptionPayload
  externalAccount(where: ExternalAccountSubscriptionWhereInput): ExternalAccountSubscriptionPayload
  project(where: ProjectSubscriptionWhereInput): ProjectSubscriptionPayload
  projectLike(where: ProjectLikeSubscriptionWhereInput): ProjectLikeSubscriptionPayload
  userAccount(where: UserAccountSubscriptionWhereInput): UserAccountSubscriptionPayload
  userProfile(where: UserProfileSubscriptionWhereInput): UserProfileSubscriptionPayload
}

type UserAccount {
  id: ID!
  email: String!
  password: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserAccountConnection {
  pageInfo: PageInfo!
  edges: [UserAccountEdge]!
  aggregate: AggregateUserAccount!
}

input UserAccountCreateInput {
  id: ID
  email: String!
  password: String!
}

type UserAccountEdge {
  node: UserAccount!
  cursor: String!
}

enum UserAccountOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserAccountPreviousValues {
  id: ID!
  email: String!
  password: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserAccountSubscriptionPayload {
  mutation: MutationType!
  node: UserAccount
  updatedFields: [String!]
  previousValues: UserAccountPreviousValues
}

input UserAccountSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserAccountWhereInput
  AND: [UserAccountSubscriptionWhereInput!]
  OR: [UserAccountSubscriptionWhereInput!]
  NOT: [UserAccountSubscriptionWhereInput!]
}

input UserAccountUpdateInput {
  email: String
  password: String
}

input UserAccountUpdateManyMutationInput {
  email: String
  password: String
}

input UserAccountWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserAccountWhereInput!]
  OR: [UserAccountWhereInput!]
  NOT: [UserAccountWhereInput!]
}

input UserAccountWhereUniqueInput {
  id: ID
  email: String
}

type UserProfile {
  id: ID!
  userAccountId: ID!
  email: String!
  firstName: String
  lastName: String
  profileImage: String
  city: String
  zip: String
  address: String
  state: String
  aptNumber: String
  projects(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Project!]
  projectLikes(where: ProjectLikeWhereInput, orderBy: ProjectLikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectLike!]
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  commentLikes(where: CommentLikeWhereInput, orderBy: CommentLikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CommentLike!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserProfileConnection {
  pageInfo: PageInfo!
  edges: [UserProfileEdge]!
  aggregate: AggregateUserProfile!
}

input UserProfileCreateInput {
  id: ID
  userAccountId: ID!
  email: String!
  firstName: String
  lastName: String
  profileImage: String
  city: String
  zip: String
  address: String
  state: String
  aptNumber: String
  projects: ProjectCreateManyWithoutProfileInput
  projectLikes: ProjectLikeCreateManyWithoutProfileInput
  comments: CommentCreateManyWithoutProfileInput
  commentLikes: CommentLikeCreateManyWithoutProfileInput
}

input UserProfileCreateOneWithoutCommentLikesInput {
  create: UserProfileCreateWithoutCommentLikesInput
  connect: UserProfileWhereUniqueInput
}

input UserProfileCreateOneWithoutCommentsInput {
  create: UserProfileCreateWithoutCommentsInput
  connect: UserProfileWhereUniqueInput
}

input UserProfileCreateOneWithoutProjectLikesInput {
  create: UserProfileCreateWithoutProjectLikesInput
  connect: UserProfileWhereUniqueInput
}

input UserProfileCreateOneWithoutProjectsInput {
  create: UserProfileCreateWithoutProjectsInput
  connect: UserProfileWhereUniqueInput
}

input UserProfileCreateWithoutCommentLikesInput {
  id: ID
  userAccountId: ID!
  email: String!
  firstName: String
  lastName: String
  profileImage: String
  city: String
  zip: String
  address: String
  state: String
  aptNumber: String
  projects: ProjectCreateManyWithoutProfileInput
  projectLikes: ProjectLikeCreateManyWithoutProfileInput
  comments: CommentCreateManyWithoutProfileInput
}

input UserProfileCreateWithoutCommentsInput {
  id: ID
  userAccountId: ID!
  email: String!
  firstName: String
  lastName: String
  profileImage: String
  city: String
  zip: String
  address: String
  state: String
  aptNumber: String
  projects: ProjectCreateManyWithoutProfileInput
  projectLikes: ProjectLikeCreateManyWithoutProfileInput
  commentLikes: CommentLikeCreateManyWithoutProfileInput
}

input UserProfileCreateWithoutProjectLikesInput {
  id: ID
  userAccountId: ID!
  email: String!
  firstName: String
  lastName: String
  profileImage: String
  city: String
  zip: String
  address: String
  state: String
  aptNumber: String
  projects: ProjectCreateManyWithoutProfileInput
  comments: CommentCreateManyWithoutProfileInput
  commentLikes: CommentLikeCreateManyWithoutProfileInput
}

input UserProfileCreateWithoutProjectsInput {
  id: ID
  userAccountId: ID!
  email: String!
  firstName: String
  lastName: String
  profileImage: String
  city: String
  zip: String
  address: String
  state: String
  aptNumber: String
  projectLikes: ProjectLikeCreateManyWithoutProfileInput
  comments: CommentCreateManyWithoutProfileInput
  commentLikes: CommentLikeCreateManyWithoutProfileInput
}

type UserProfileEdge {
  node: UserProfile!
  cursor: String!
}

enum UserProfileOrderByInput {
  id_ASC
  id_DESC
  userAccountId_ASC
  userAccountId_DESC
  email_ASC
  email_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  profileImage_ASC
  profileImage_DESC
  city_ASC
  city_DESC
  zip_ASC
  zip_DESC
  address_ASC
  address_DESC
  state_ASC
  state_DESC
  aptNumber_ASC
  aptNumber_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserProfilePreviousValues {
  id: ID!
  userAccountId: ID!
  email: String!
  firstName: String
  lastName: String
  profileImage: String
  city: String
  zip: String
  address: String
  state: String
  aptNumber: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserProfileSubscriptionPayload {
  mutation: MutationType!
  node: UserProfile
  updatedFields: [String!]
  previousValues: UserProfilePreviousValues
}

input UserProfileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserProfileWhereInput
  AND: [UserProfileSubscriptionWhereInput!]
  OR: [UserProfileSubscriptionWhereInput!]
  NOT: [UserProfileSubscriptionWhereInput!]
}

input UserProfileUpdateInput {
  userAccountId: ID
  email: String
  firstName: String
  lastName: String
  profileImage: String
  city: String
  zip: String
  address: String
  state: String
  aptNumber: String
  projects: ProjectUpdateManyWithoutProfileInput
  projectLikes: ProjectLikeUpdateManyWithoutProfileInput
  comments: CommentUpdateManyWithoutProfileInput
  commentLikes: CommentLikeUpdateManyWithoutProfileInput
}

input UserProfileUpdateManyMutationInput {
  userAccountId: ID
  email: String
  firstName: String
  lastName: String
  profileImage: String
  city: String
  zip: String
  address: String
  state: String
  aptNumber: String
}

input UserProfileUpdateOneRequiredWithoutCommentLikesInput {
  create: UserProfileCreateWithoutCommentLikesInput
  update: UserProfileUpdateWithoutCommentLikesDataInput
  upsert: UserProfileUpsertWithoutCommentLikesInput
  connect: UserProfileWhereUniqueInput
}

input UserProfileUpdateOneRequiredWithoutCommentsInput {
  create: UserProfileCreateWithoutCommentsInput
  update: UserProfileUpdateWithoutCommentsDataInput
  upsert: UserProfileUpsertWithoutCommentsInput
  connect: UserProfileWhereUniqueInput
}

input UserProfileUpdateOneRequiredWithoutProjectLikesInput {
  create: UserProfileCreateWithoutProjectLikesInput
  update: UserProfileUpdateWithoutProjectLikesDataInput
  upsert: UserProfileUpsertWithoutProjectLikesInput
  connect: UserProfileWhereUniqueInput
}

input UserProfileUpdateOneRequiredWithoutProjectsInput {
  create: UserProfileCreateWithoutProjectsInput
  update: UserProfileUpdateWithoutProjectsDataInput
  upsert: UserProfileUpsertWithoutProjectsInput
  connect: UserProfileWhereUniqueInput
}

input UserProfileUpdateWithoutCommentLikesDataInput {
  userAccountId: ID
  email: String
  firstName: String
  lastName: String
  profileImage: String
  city: String
  zip: String
  address: String
  state: String
  aptNumber: String
  projects: ProjectUpdateManyWithoutProfileInput
  projectLikes: ProjectLikeUpdateManyWithoutProfileInput
  comments: CommentUpdateManyWithoutProfileInput
}

input UserProfileUpdateWithoutCommentsDataInput {
  userAccountId: ID
  email: String
  firstName: String
  lastName: String
  profileImage: String
  city: String
  zip: String
  address: String
  state: String
  aptNumber: String
  projects: ProjectUpdateManyWithoutProfileInput
  projectLikes: ProjectLikeUpdateManyWithoutProfileInput
  commentLikes: CommentLikeUpdateManyWithoutProfileInput
}

input UserProfileUpdateWithoutProjectLikesDataInput {
  userAccountId: ID
  email: String
  firstName: String
  lastName: String
  profileImage: String
  city: String
  zip: String
  address: String
  state: String
  aptNumber: String
  projects: ProjectUpdateManyWithoutProfileInput
  comments: CommentUpdateManyWithoutProfileInput
  commentLikes: CommentLikeUpdateManyWithoutProfileInput
}

input UserProfileUpdateWithoutProjectsDataInput {
  userAccountId: ID
  email: String
  firstName: String
  lastName: String
  profileImage: String
  city: String
  zip: String
  address: String
  state: String
  aptNumber: String
  projectLikes: ProjectLikeUpdateManyWithoutProfileInput
  comments: CommentUpdateManyWithoutProfileInput
  commentLikes: CommentLikeUpdateManyWithoutProfileInput
}

input UserProfileUpsertWithoutCommentLikesInput {
  update: UserProfileUpdateWithoutCommentLikesDataInput!
  create: UserProfileCreateWithoutCommentLikesInput!
}

input UserProfileUpsertWithoutCommentsInput {
  update: UserProfileUpdateWithoutCommentsDataInput!
  create: UserProfileCreateWithoutCommentsInput!
}

input UserProfileUpsertWithoutProjectLikesInput {
  update: UserProfileUpdateWithoutProjectLikesDataInput!
  create: UserProfileCreateWithoutProjectLikesInput!
}

input UserProfileUpsertWithoutProjectsInput {
  update: UserProfileUpdateWithoutProjectsDataInput!
  create: UserProfileCreateWithoutProjectsInput!
}

input UserProfileWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  userAccountId: ID
  userAccountId_not: ID
  userAccountId_in: [ID!]
  userAccountId_not_in: [ID!]
  userAccountId_lt: ID
  userAccountId_lte: ID
  userAccountId_gt: ID
  userAccountId_gte: ID
  userAccountId_contains: ID
  userAccountId_not_contains: ID
  userAccountId_starts_with: ID
  userAccountId_not_starts_with: ID
  userAccountId_ends_with: ID
  userAccountId_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  profileImage: String
  profileImage_not: String
  profileImage_in: [String!]
  profileImage_not_in: [String!]
  profileImage_lt: String
  profileImage_lte: String
  profileImage_gt: String
  profileImage_gte: String
  profileImage_contains: String
  profileImage_not_contains: String
  profileImage_starts_with: String
  profileImage_not_starts_with: String
  profileImage_ends_with: String
  profileImage_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  zip: String
  zip_not: String
  zip_in: [String!]
  zip_not_in: [String!]
  zip_lt: String
  zip_lte: String
  zip_gt: String
  zip_gte: String
  zip_contains: String
  zip_not_contains: String
  zip_starts_with: String
  zip_not_starts_with: String
  zip_ends_with: String
  zip_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  aptNumber: String
  aptNumber_not: String
  aptNumber_in: [String!]
  aptNumber_not_in: [String!]
  aptNumber_lt: String
  aptNumber_lte: String
  aptNumber_gt: String
  aptNumber_gte: String
  aptNumber_contains: String
  aptNumber_not_contains: String
  aptNumber_starts_with: String
  aptNumber_not_starts_with: String
  aptNumber_ends_with: String
  aptNumber_not_ends_with: String
  projects_every: ProjectWhereInput
  projects_some: ProjectWhereInput
  projects_none: ProjectWhereInput
  projectLikes_every: ProjectLikeWhereInput
  projectLikes_some: ProjectLikeWhereInput
  projectLikes_none: ProjectLikeWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  commentLikes_every: CommentLikeWhereInput
  commentLikes_some: CommentLikeWhereInput
  commentLikes_none: CommentLikeWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserProfileWhereInput!]
  OR: [UserProfileWhereInput!]
  NOT: [UserProfileWhereInput!]
}

input UserProfileWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    